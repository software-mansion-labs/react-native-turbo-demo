<h1 class="page-title display-native --turbo-streams">
  <div class="actions__icon --turbo-streams" aria-hidden="true"></div>
  Turbo Streams: Deliver live page changes
</h1>

<p>
  Making partial page changes in response to asynchronous actions is how we make the application feel alive. While Turbo Frames give us such updates in response to direct interactions within a single frame, Turbo Streams let us change any part of the page in response to updates sent over a WebSocket connection, SSE or other transport. (Think an imbox that automatically updates when a new email arrives.)
</p>

<p>
  Turbo Streams introduces a 'turbo-stream' element with seven basic actions: append, prepend, replace, update, remove, before, and after. With these actions, along with the target attribute specifying the ID of the element you want to operate on, you can encode all the mutations needed to refresh the page. You can even combine several stream elements in a single stream message. Simply include the HTML you’re interested in inserting or replacing in a template tag and Turbo does the rest.
</p>

<p>
  <strong>Reuse the server-side templates:</strong> Live page changes are generated using the same server-side templates that were used to create the first-load page.
</p>

<p>
  <strong>HTML over the wire:</strong> Since all we’re sending is HTML, you don’t need any client-side JavaScript (beyond Turbo, of course) to process the update. Yes, the HTML payload might be a tad larger than a comparable JSON, but with gzip, the difference is usually negligible, and you save all the client-side effort it takes to fetch JSON and turn it into HTML.
</p>

<p>
  <strong>Simpler control flow:</strong> It’s really clear to follow what happens when messages arrive on the WebSocket, SSE or in response to form submissions. There’s no routing, event bubbling, or other indirection required. It’s just the HTML to be changed, wrapped in a single tag that tells us how.
</p>

<p>
  Now, unlike RJS and SJR, it’s not possible to call custom JavaScript functions as part of a Turbo Streams action. But this is a feature, not a bug. Those techniques can easily end up producing a tangled mess when way too much JavaScript is sent along with the response. Turbo focuses squarely on just updating the DOM, and then assumes you’ll connect any additional behavior using Stimulus actions and lifecycle callbacks.
</p>

<p>
  <a href="https://turbo.hotwired.dev/handbook/streams" target="_blank" class="button">Come Alive with Turbo Streams</a>
</p>